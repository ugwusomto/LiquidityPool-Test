{"ast":null,"code":"import detectEthereumProvider from \"@metamask/detect-provider\";\nimport { ethers } from \"ethers\";\nimport { NETWORKS } from \"./constants\";\nexport const isEmpty = data => {\n  return !data || data.length === 0 || typeof data == \"undefined\" || data == null || Object.keys(data) === 0;\n}; //This function connects to the blockchain and read data\n\nexport const getReadOnlyProvider = async () => {\n  const provider = await detectEthereumProvider();\n\n  if (provider && provider === window.ethereum) {\n    return new ethers.providers.Web3Provider(provider, \"any\");\n  } else {\n    return false;\n  }\n};\nexport const getRigelPoolContract = async (provider, contractData) => {\n  const network = NETWORKS[NETWORKS[\"ACTIVE\"]];\n  const networkInfo = isEmpty(contractData.networks[network.chainId]) ? contractData.networks[5777] : contractData.networks[network.chainId];\n  const address = networkInfo.address;\n  const contractABI = contractData.abi;\n  return new ethers.Contract(address, contractABI, provider);\n};\nexport function message(type, message) {\n  Swal.fire({\n    position: 'top-end',\n    icon: `${type}`,\n    title: `${message}`,\n    showConfirmButton: false,\n    timer: 4000\n  });\n}","map":{"version":3,"sources":["/Users/t/Documents/BLOCKCHAIN PROJECT/LiquidityPool-Test/front-end/src/utils.js"],"names":["detectEthereumProvider","ethers","NETWORKS","isEmpty","data","length","Object","keys","getReadOnlyProvider","provider","window","ethereum","providers","Web3Provider","getRigelPoolContract","contractData","network","networkInfo","networks","chainId","address","contractABI","abi","Contract","message","type","Swal","fire","position","icon","title","showConfirmButton","timer"],"mappings":"AAAA,OAAOA,sBAAP,MAAmC,2BAAnC;AACA,SAASC,MAAT,QAAuB,QAAvB;AACA,SAASC,QAAT,QAAwB,aAAxB;AAEA,OAAO,MAAMC,OAAO,GAAIC,IAAD,IAAU;AAC7B,SACE,CAACA,IAAD,IAASA,IAAI,CAACC,MAAL,KAAgB,CAAzB,IAA8B,OAAOD,IAAP,IAAe,WAA7C,IAA4DA,IAAI,IAAI,IAApE,IAA4EE,MAAM,CAACC,IAAP,CAAYH,IAAZ,MAAsB,CADpG;AAGD,CAJI,C,CAMP;;AACA,OAAO,MAAMI,mBAAmB,GAAG,YAAY;AAC3C,QAAMC,QAAQ,GAAG,MAAMT,sBAAsB,EAA7C;;AACA,MAAGS,QAAQ,IAAIA,QAAQ,KAAKC,MAAM,CAACC,QAAnC,EAA4C;AAC1C,WAAO,IAAIV,MAAM,CAACW,SAAP,CAAiBC,YAArB,CAAkCJ,QAAlC,EAA2C,KAA3C,CAAP;AACD,GAFD,MAEK;AACH,WAAO,KAAP;AACD;AACJ,CAPM;AAUP,OAAO,MAAMK,oBAAoB,GAAG,OAAOL,QAAP,EAAkBM,YAAlB,KAAoC;AACpE,QAAMC,OAAO,GAAGd,QAAQ,CAACA,QAAQ,CAAC,QAAD,CAAT,CAAxB;AACA,QAAMe,WAAW,GAAGd,OAAO,CAACY,YAAY,CAACG,QAAb,CAAsBF,OAAO,CAACG,OAA9B,CAAD,CAAP,GAAkDJ,YAAY,CAACG,QAAb,CAAsB,IAAtB,CAAlD,GAAgFH,YAAY,CAACG,QAAb,CAAsBF,OAAO,CAACG,OAA9B,CAApG;AACA,QAAMC,OAAO,GAAGH,WAAW,CAACG,OAA5B;AACA,QAAMC,WAAW,GAAGN,YAAY,CAACO,GAAjC;AACA,SAAO,IAAIrB,MAAM,CAACsB,QAAX,CAAoBH,OAApB,EAA4BC,WAA5B,EAAwCZ,QAAxC,CAAP;AACH,CANM;AASP,OAAO,SAASe,OAAT,CAAiBC,IAAjB,EAAwBD,OAAxB,EAAgC;AACrCE,EAAAA,IAAI,CAACC,IAAL,CAAU;AACNC,IAAAA,QAAQ,EAAE,SADJ;AAENC,IAAAA,IAAI,EAAE,GAAEJ,IAAK,EAFP;AAGNK,IAAAA,KAAK,EAAG,GAAEN,OAAQ,EAHZ;AAINO,IAAAA,iBAAiB,EAAE,KAJb;AAKNC,IAAAA,KAAK,EAAE;AALD,GAAV;AAOD","sourcesContent":["import detectEthereumProvider from \"@metamask/detect-provider\";\nimport { ethers } from \"ethers\";\nimport { NETWORKS} from \"./constants\";\n\nexport const isEmpty = (data) => {\n    return (\n      !data || data.length === 0 || typeof data == \"undefined\" || data == null || Object.keys(data) === 0\n    );\n  };\n\n//This function connects to the blockchain and read data\nexport const getReadOnlyProvider = async () => {\n    const provider = await detectEthereumProvider();\n    if(provider && provider === window.ethereum){\n      return new ethers.providers.Web3Provider(provider,\"any\");\n    }else{\n      return false;\n    }\n}\n\n\nexport const getRigelPoolContract = async (provider , contractData ) => {\n    const network = NETWORKS[NETWORKS[\"ACTIVE\"]];\n    const networkInfo = isEmpty(contractData.networks[network.chainId]) ? contractData.networks[5777] : contractData.networks[network.chainId];\n    const address = networkInfo.address;\n    const contractABI = contractData.abi;\n    return new ethers.Contract(address,contractABI,provider);\n}\n\n\nexport function message(type , message){\n  Swal.fire({\n      position: 'top-end',\n      icon:`${type}`,\n      title: `${message}`,\n      showConfirmButton: false,\n      timer: 4000\n  }) \n}"]},"metadata":{},"sourceType":"module"}